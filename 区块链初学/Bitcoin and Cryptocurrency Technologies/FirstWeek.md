1.加密哈希函数  
三个属性：collision-free hiding property puzzle-friendly  
collision-free：无碰撞。即对于不同的x,y 加密结果H(x),H(y)也是“必定”不同的。这里的“必定”是指在不同的x,y使得H(x)=H(y)是存在的，但是有效的时间内是找不到的。  
hiding property：隐藏信息。即根据哈希计算后的结果，无法倒推出源信息x是什么。原本可以通过对所有x的可能进行hash计算，然后比对判断是哪一个。但是通过在x后加上一个key，该key是从一个大数量可能性的集合中得到的。从而将加密前的信息的可能性扩充到无穷大。  
puzzle-friendly：搜索难题。对于一个从一个大量集合中取出的x，计算哈希之后得到y。我们先给出y。如果我们给出x，去验证x是否是y的源信息是非常简单的，仅需一次哈希计算。但是仅给出y，然后去寻找x是非常困难的，除了对x所属的集合中的每一个值进行哈希运算然后判断是否和y相同之歌办法以外，并没有一个更好的办法。这是一个难题。  
最常用的哈希函数：SHA-256。将需要加密的文件按512bit进行分块，最后一个不足512bit的块，在末尾添加一个说明文件长度的64bits的值以及用于填充用的0。使得文件最终为k个512bits的块。然后先从标准文件中找到一个256bits的key，将该key加在第一个块的后面，形成一个768bits的字符串，然后通过哈希函数计算，得到一个256bits的值，然后再将其附到第二块后面，以此类推直到最后得到一个256bits 的最终加密结果。  
2.哈希指针和数据结构  
哈希指针是指一个指向 数据存储位置及其位置哈希值的 指针  
哈希链表：区块链的账本  
像普通链表一样，链表中有一系列区块 每个区块既有数据也有一个指向上一个区块的指针 而在区块链中，上一个区块指针被置换为哈希指针 因此，每个区块不仅能告诉我们上一个区块的值在哪里 还包含了上一个区块的值的哈希值 使我们能够验证那个值没有改变 就像一个普通的哈希指针一样。  
哈希二叉树：Merkle树  
所有的区块信息均存储在叶子节点上，然后每2个叶子节点的父节点是其值的哈希值，然后层层计算哈希直到根节点。  
所有无环结构均可使用哈希指针从新构建以达到，防篡改的功能。  
3.数字签名  
三个操作  
一.我们有一个generateKeys操作 然后我们告诉它keysize，密钥的位数该有多大 这样就产生了两个密钥，sk，pk sk是一个私钥 这是你需要安全保存，用于签署签名的 pk是一个用于验证的公钥，你将它给所有人 每个人都可以在见到你签名的时候用公钥确认   
二.签署操作 签署sign操作，使用你的私钥 以及你想要签名的消息 该操作返回签名sig sig是一串表示你签名的字符     
三. 验证verify，它接收 声称是有效的签名，验证它是有效的 它需要签署者的公钥，应有签名的消息 以及应有的签名 它只是说yes or no   
算法需要两个保证，保证能验证；保证无法伪造。  
4.将公钥作为身份信息。  
你需要新的身份时，仅需要直接生成一对 公私钥对即可，通过私钥对信息进行签名，将公钥公开出去作为你的身份标识。并且生成的秘钥和你的现实身份信息没有任何关联，因此可以去除一个中心化的身份分配机构。  
但一个缺点就是，一旦你的这个身份即公钥和“你”建立了联系，那么该公钥的以往的所有的交易信息、声明信息均会和“你”联系起来。  
5.加密货币雏形。  
货币:是一串交易信息。  
交易：将货币的交易信息用自己的私钥进行签名。  
双花问题：一枚货币会被花费两次  
中心化问题：无法保证造币单位保持永远的诚实。  
